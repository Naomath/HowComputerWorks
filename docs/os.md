## 取り扱う項目
- WSLセットアップ
- オペレーティングシステム
    - 概論
    - Linux基本コマンド
    - プロセスが動いている様子を理解する
    - カーネル
    - コンパイルを理解する

## WSLセットアップ
Windows Subsystems for LinuxはWindowsでLinuxを実行するためのソフトウェアです。
LinuxとはOSの一種で、オープンソースで完全に公開されています。
プログラミングや研究開発などで広く使われており、Linuxの中でもさらにバージョンのようなものがあり、それをディストリビューションと言います。
WindowsのようにリッチなGUIで動かせるもの、コマンドラインだけで実行するもの、サーバー用途に特化したもの、などさまざまなものがありますが、おそらく一番使われているのはUbuntuでしょう。
ここでは、WindowsにWSLをインストールし、その中でUbuntuを使えるようにセットアップします。

まず、[このサイト](https://apps.microsoft.com/detail/9p9tqf7mrm4r?hl=ja-JP&gl=JP)から「インストール」を押してください。
アプリストアが起動されると思いますが、そこでも「インストール」を押して、進めてください。

インストールが終わったら、Windowsの下のバーの検索窓から、「Powershell」を「管理者として実行」を選択して実行してください。
実行できたら以下のコマンドを入力して、Enterを押して実行してください。
```
wsl --install
```

インストールできたら、ユーザー名、パスワードの順番で聞かれるのでそれぞれ適当に設定してください。
設定できて、``username@machine:/mnt/c/Windows/system32 $``となったら、

```
cat /etc/os-release
```
を実行してください。
これはOSのバージョンなどを確認することができるコマンドで、``Ubuntu``と表示されているのが確認できると思います。
抜けるのコマンドは``exit``で、入り直すときは、PowerwShellから``wsl``です。

## オペレーティングシステム
### 概論
オペレーティングシステムはOSと呼ばれ、特に、WindowsとMacが有名なのではないでしょうか。
コンピューターのOSだけではなく、AndroidやiOSもスマートフォンのOSです。
OSの役割としては、以下の東大の田浦先生の授業スライド（ネットで公開されている）の解説がわかりやすいので、ぜひ一読してみてください。

[田浦健次郎　オペレーティングシステム　第一回スライド](https://taura.github.io/operating-systems/slides/00_intro.pdf)

アプリケーションやソフトウェアはOSの中に入れるというイメージですので、OSの方がより低レイヤーになります。
OSはハードウェア（コンピューターそのもの）に入れるので、ハードウェアとソフトウェアを繋ぐものになります。
以下の3点がOSの要点になります。
- 複数のプログラム、ソフトウェア、アプリケーションを同時に動かせるようにする
- メモリやCPUのコアなどの資源の分配を効率化する
- ハードウェアの操作を簡単にする

複数のプログラムを同時に動かすために、OSは複数のコアに対してプロセス（プログラムが実行されているもの）を分配しています。
資源の分配として、プロセスごとにメモリやコアの割り当てを行います。
ハードウェアの操作を簡単にする、というのはソフトウェア側からの視点ですが、例えば、画面の1ピクセルごとにどうする、みたいなアセンブリのプログラムを描かなくて、例えば、座標を指定して円の描画を指示する、というより抽象的な1行のプログラムを実行できるようになります。
もう少し詳しく言えば、OSに入るライブラリのおかげでこのような抽象的なプログラムが書けるようになると言えます。

### Linux基本コマンド
Linuxでは基本的にはコマンドラインを使って操作します。
マウスやトラックパッドで操作するUI(ユーザーインターフェース)をGUI graphical user interface というのに対して、コマンドラインで操作するUIをCLI command line interface と言います。
また、コマンドラインの規格、シェル（例えば、これから紹介する``pwd``がどういう操作になるか）はOSの間で統一はされておらず、有名なものとして、Bash（バッシュ）やZsh（ズィーシェル）があります。
シェルはLinuxに特有のものではなくて、WindowsのPowerShellもその一種です。

まずは、Ubuntuのシェルが何で動いているかを確認するコマンドを打ちます。
```bash
echo $SHELL
```
出力はおそらく、``/bin/bash`` となりますが、これは、``/bin/bash``というパスにある``bash``というプログラムがこのシェルの正体です、ということです。
``echo``は引数（関数の入力のこと。情報科学で特有の言い回し）にとったものを出力するコマンドです。

次に、ディレクトリという概念を勉強します。
ディレクトリとは、ファイルであったりシェルがどこにあるか、というものです。
例えば、``pwd``はシェルが今どこで操作をしているかを出力するコマンドですが、その出力が以下だとします。

```bash
/home/hpcadm
```
これは、``/``という全ての始まりのフォルダの、``home``というフォルダの``hpcadm``というフォルダにいるということになります。
例えるなら、住所のようなもので、東京都目黒区駒場、というようにどんどんと狭まっていきます。

[Qiita Linuxコマンド入門(1) ~ディレクトリ操作~](https://qiita.com/LostEnryu/items/89f67cf608cd244373b1)

このサイトに詳しくディレクトリ操作については書いてあるので、以下のコマンドの意味については理解できるのが望しいです。

- ``cd ../``
- ``cd ~``
- ``ls ../``
- ``mkdir folder1 && cd folder1``
- ``ls > ls.txt``
- ``cat ls.txt``


また、``touch test.txt``などを作成してからそれを編集するためには、vimもしくはnanoを使うのがいいです。
本格的にテキスト編集をするならばvimですが、軽く確認のために使う程度ならnanoで十分なので、以下のコマンドでテキストファイルを作り、nanoで編集してみましょう。

```bash
touch test.txt
nano test.txt
```

### プロセスが動いている様子を理解する
Linuxでは一つのプロセスが一つのコアで動いているので、最小の実行単位です。
正確にはカーネルスレッドですが、ここでは省略します。
プロセスが動いている様子を観察できるコマンドをいくつか紹介します。

まずは一番有名な``ps``コマンドです。
これは現在動いているプロセスのスナップショットを表示してくれるコマンドです。
以下のようにオプションをつけて動かしてみましょう。
ちなみに``|``はパイプといって、一つ目のコマンドの標準出力（黒画面に表示される文字列）を二つ目のコマンドの標準入力とする機能で、``less``という長文をみやすくするコマンドに表示が長くなるであろう全プロセスを表示するコマンドを入れています。

```bash
ps auxww | less
```

PIDとはprocess ID、%CPUや%MEMはそのプロセスのCPUとメモリでの使用割合です。
とはいってもこれだとその瞬間だけでよくわからないので、以下のリアルタイムで更新するコマンドを実行してください。

```bash
top
```
実行を終了するときは、``Ctrl+C``です。
また、ターミナルの入力行を一番上に持ってくるときは、``clear``というコマンドが使えます。
また、コマンドの詳細を知るためには、もちろんインターネットで調べたり、ChatGPTに聞いたり、することもできるのですが、``man``コマンドが便利です。
以下のように入力すれば、``ps``コマンドの詳細について知ることができます。
表示を終了するときは``q``を入力してください。

```bash 
man ps
```

プロセスの生成についてですが、プロセスは別のプロセスから起動されるので、親子関係が規定されます。
Ubuntuでは``systemed``というプロセスが電源投入後に最初に起動され、PID1が付与されます。
それでは、プロセスの親子関係を見てみましょう。
```bash
pstree -p
```

こうしてみると、おそらく``pstree``が``bash``から生えていたり、``systemed``から多数のプロセスが起動されている様子が観察できるでしょう。
つまり、この親子関係を表示するコマンドは、``pstree``という名前のプロセスをシェルプロセスの``bash``から起動しているということです。

コマンドを入力すると、プロセスの実行が始まり、終了したらまたコマンドを受け付けるようになりますが、プロセスを途中で終了させる、ということをしてみます。
例えば、以下の1000秒間何もしない、というコマンドを、ターミナルの裏で実行することを表す``&``をつけて入力してみてください。
```bash 
sleep 1000 &
```
こうすると出力で例えば以下のように出てきます。
```bash
[1] 25727
```
これは、この``sleep``プロセスのPIDを表していて、``ps auxww | grep 25727`でも確認できます。
この``grep``というのは引数の文字列を入力から探してきて、含まれている行を出力するコマンドです。
そして、このプロセスを強制終了するには、``kill 25727``を実行してください。
実行してから、再度``ps auxww | grep 25727``を入力して、``sleep``プロセスの終了を確認してください。
例えば、サーバー管理をしているときに、``top``コマンドで実行中のプロセスをモニタリングしていて、暴走している(CPUやメモリの使用量が過度に多いなど)プロセスがあったときに、そのプロセスを強制終了するといった場面で、この``kill``コマンドは役に立ちます。

###　カーネル
OSのソフトウェアのことを、Linuxではカーネル(kernel、核)といいます。
カーネルというソフトウェアの中で、いくつものプロセスが動いていて、CPUやメモリの割り当ての管理をカーネルが行なっています。
さて、ここで少し話が飛びますが、CPUの二つのモードについて解説します。

CPUにはユーザーモードと特権モードというのがあります。
特権モードのときは、特権命令（命令がCPUが実行するプログラムの最小単位）を実行することができ、この特権命令はメモリやデバイス（キーボードやディスプレイ）を直接操作することができます。
直接操作する、というのはキーボードから入力された文字を読み込むことも含んでいっています。

**ユーザモード (User Mode)**

- 一般のアプリケーションプログラムが動作するモード
- 制限付きの実行環境
- 特権命令を実行できない
- ハードウェア資源（I/O, メモリ管理など）に直接アクセスできない
- 特権命令を実行しようとすると例外（トラップ）が発生し、カーネルに制御が移る

**特権モード (Kernel Mode / Supervisor Mode)**

- OSカーネルやデバイスドライバなど、システムの中核が動作するモード
- 制限のない実行環境
- 特権命令を実行可能
- メモリ管理やI/O操作など、ハードウェア資源を直接制御できる
- システムコールを通じてユーザモードから一時的に切り替わる

例えば、カーネルはプロセスに資源（CPUやメモリ）の割り当てをするので、CPUが特権モードの状態で動いている、というのがわかります。
カーネルはプロセスの資源を管理する一方で、システムコールという機能を提供しています。
例えば、プロセスが入力から読み込んだりするときには、特権命令が必要になるので、カーネルの提供するシステムコールを呼び出して、カーネルが特権モードで入力を読み込みます。

では、実際にプロセスがどのようなシステムコールを呼んでいるかを調べてみましょう。
``strace``というコマンドで引数のコマンドの実行にどのようなシステムコールが呼ばれているかを調べることができます。
以下のコマンドを実行してください。

```bash
strace -o trace.log cat ls.txt
```
これで、``nano trace.log``などでログファイルを開いてみましょう。
各行がシステムコールに対応していますが、かいつまんで解説します。

| システムコール | 操作 | 
|:-----------|:------------|
| ``execve`` | 新しいプロセスを生成する |
| ``mmap``   | メモリに領域を確保する |
| ``read``   | ファイルや端末の入力を読み込む |
| ``write``  | ファイルや端末の出力に書き込む |

### コンパイルを理解する
それでは、最後にコードからコンピューターで実行されるところまで実践してみます。
まず、今回実行するC言語のコードは以下です。

```c
#include<stdio.h>
int main() {
    printf("Hello, World!\n");
    return 0;
}
```
これは端末に``Hello,World!``と表示するコードです。
ちなみに``stdio``はstandard IOの略称です。
IOとはInput/Outputのことで、``printf``を使用するためのライブラリです。

これを順に実行可能ファイル（バイナリ）にするまでは以下の手順を踏みます。

1. コンパイル: ``hello.c``からアセンブリ``hello.s``に変換
2. アセンブル: ``hello.s``からオブジェクトコード``hello.o``に変換
3. リンク: ``hello.o``と必要なライブラリのオブジェクトファイルを組み合わせて、バイナリ``hello.out``を生成

一つずつ細かくみていきます。
まずは、コンパイルするために以下のコマンドを実行してください。
```bash
gcc -S hello.c -o hello.s
```
nanoやvimで中身を確認してみましょう。
``call puts@PLT``というところで、``puts``というシステムコールを呼んでいます。

次にこれをアセンブルして、オブジェクトコードに変換します。
```bash
gcc -c hello.s -o hello.o
```
この``hello.o``ファイルは機械語なので、これをそのままvimなどで開いても文字化けしているだけです。
``objdump -d hello.o``とすると、逆アセンブルといって、機械語からアセンブリへと変換した結果をみることができます。

最後にリンクします。
```bash
gcc hello.o -o hello.out
```
そして、以下のコマンドで実行して、``Hello, World!``と表示されているのを確認できます。
```bash
./hello.out
```

さて、ここでリンクは何をしているでしょう。
アセンブルしただけの``hello.o``では、ライブラリと適切に紐づけられていない、そしてプロセスとして共通のはじまる手順や終わる手順を含んでいません。
まず、ライブラリとは、よく使う機能などをどのアプリからでも使えるようにまとめたパッケージになります。
例えば、``printf``は``printf("Number %d", number)``とすることで、変数``number``の値が表示されるようになるなど、便利な機能がいろいろあります。
これを毎回自前で作成していると大変なので、他のプロセスからも参照できるように開発環境にダウンロードしておきます。
そして、それを参照するようにコードには書くだけで、その開発環境では、必要なコードを事前にダウンロードしていたファイルから抜いて、他のコンピューターに移しても実行可能なバイナリを作成することができます。
というのが静的リンクの仕組みで、正確には動的リンクの方が多く、OSと絡んでくるのはそちらなのですが、一旦省略します。
また、どのプロセスも必要なはじめと終わりの手順は最後にまとめて入れてしまうだけで十分なので、最後のリンクでそれらも含めています。

実際に、リンクしたバイナリで、``objdump -d hello.out``を実行してみましょう。
先ほどの結果より多くのコードが出てくることがわかると思います。